# 数据结构与算法

# by tasike

## 1.顺序表(Sequence List)

```c++
#include <iostream>
using namespace std;
const int MAXSIZE = 1024;

typedef struct{
    int coef;
    int exp;
}ElemType;
typedef struct{
    ElemType *elem;
    int length;
}SqList;

SqList L;
//顺序表初始化
int InitList(SqList &L) 
{
    L.elem = new ElemType[MAXSIZE];  //动态分配内存，若分配成功返回DataType类型的指针,否则返回空指针
    if(!L.elem)
    {
        cerr << "error" << endl;
        return 0;
    }
    L.length = 0;
    return 1;
}
//顺序表的销毁
void DestroyList(SqList &L)
{
    if(L.elem)
        delete L.elem;
}
//顺序表的清空
void ClearList(SqList &L)
{
    L.length = 0;
}
//判断顺序表是否为空
int IsEmpty(SqList &L)
{
    if(!L.length)
        return 1;
    else 
        return 0;
}
//顺序表的取值(获取i位置处的元素)(利用引用来取值)
int GetElem(SqList &L, int i, ElemType &e)
{
    if(i < 1 || i > L.length)
        return 0;
    e = L.elem[i - 1];
    return 1;
}
//顺序表的查找(按值查找)
int LocateList(SqList &L, ElemType e)
{
    for(int i = 0; i < L.length; i++)
    {
        if(L.elem[i] == e)
            return i + 1;
    }
    return 0; //返回0相当于没有这个元素
}
//顺序表的插入
int InsertList(SqList &L, int i, ElemType e)
{
    if(i < 1 || i > L.length)
        return 0;
    if(L.length == MAXSIZE)
        return 0;
    for(int j = L.length - 1; j >= i - 1; j--)
        L.elem[j + 1] = L.elem[j];
    L.elem[i - 1] = e;
    L.length++;  //记得要增加表长
    return 1;
}
//顺序表的删除
int DeleteList(SqList &L, int i)
{
    if(i < 1 || i > L.length)
        return 0;
    for(int j = i - 1; j < L.length; j++)
        L.elem[j] = L.elem[j + 1];
    L.length--;  //记得要减小表长
	return 1;
}
```

## 2.链表(LinkList)

> - 单链表：只有一个指针域的链表
> - 双向链表：有两个指针域分别指向前驱和后继的链表
> - 循环链表：首尾相接的链表

#### (1)单链表

```c++
#include <iostream>
using namespace std;

typedef struct{
    int coef;
    int exp;
}DataType;
typedef struct Lnode{
	DataType data;
    struct Lnode *next;
}Lnode, *LinkList;

LinkList L;
//链表的初始化
int InitList(LinkList &L)
{
    L = new Lnode;
    L->next = nullptr;
    return 1;
}
//尾插法
void CreateList(LinkList &L, int n)
{
    auto r = L;
    for(int i = 1; i <= n; i++)
    {
        auto p = new Lnode;
        cin >> p->data;
        p->next = nullptr;
        r->next = p;
        r = p;
    }
}
//判断链表是否为空
int IsEmpty(LinkList &L)
{
    if(!L->next)
        return 1;
    else 
        return 0;
}
//链表的销毁
void DeleteList(LinkList &L)
{
    while(L)
    {
        auto p = L->next;
        delete L;
        L = p;
    }
}
//链表的清空
void ClearList(LinkList &L)
{
    auto p = L->next;
    while(p)
    {
        auto q = p->next;
        delete p;
        p = q;
    }
    L->next = nullptr;  //注意这里记得最后要把L->next置为空
}
//求链表的表长
int GetLength(LinkList &L)
{
    auto p = L->next;
    int length = 0;
    while(p)
    {
        length++;
        p = p->next;
    }
    return length;
}
//去链表第i个元素
int GetElem(LinkList &L, int i, DataType &e)
{
    if(i < 1)
        return 0;
    auto p = L;
    for(int j = 1; j <= i; j++)
    {
        p = p->next;
        if(!p)
            return 0;
    }
    e = p->data;
    return 1;
}
//链表按值查找
int LocateElem(LinkList &L, DataType &e)
{
    auto p = L;
    int i = 0;
    while(p && p->data != e)
    {
        p = p->next;
        i++;
    }
    if(p)
        return i;
    else 
        return 0;  //0就是没找到，因为位置是从1开始的
}
//在第i个结点前插入元素(要先找到第i-1个结点)
int InsertList(LinkList &L, int i, DataType e)
{
    auto p = L;
    int j = 0;
    while(p && j <= i - 1)
    {
        p = p->next;
        j++;
    }
    if(p)
    {
        auto q = new Lnode;
    	q->data = e;
    	q->next = p->next;
    	p->next = q;
    	return 1;
    }
    else
        return 0;
}
//删除第i个结点
int DeleteList(LinkList &L, int i)
{
    auto p = L;
    int j = 0;
    while(p && j <= i - 1)
    {
        p = p->next;
        j++;
    }
    if(!(p->next))
        return 0;
    auto q = p->next;
    p->next = q->next;
    delete q;  //记得要释放空间
    return 1;
}
```

#### (2)循环链表(一般都是用尾指针表示)

```c++
#include <iostream>
using namespace std;

typedef struct CLnode
{
    ElemType data;
    CLnode *next;
}CLnode, *CircList;

CircList L;
//循环链表的初始化
void InitList(CircList &L)
{
    L = new	CircList;
    L->next = L;
}


while(p) -------> while(p != L)
```

#### (3)双向链表

```c++
#include <iostream>
using namespace std;

typedef struct DLnode{
    DataType data;
    struct DLnode *prior, *next;
}DLnode, *DLinkList;

DLinkList L;
//双向链表的初始化
void InitList(DLinkList &L)
{
    L = new DLnode;
    L->prior = nullptr;
    L->next = nullptr;
}
//尾插法建立双向链表
void CreateList(DLinkList &L, int n)
{
    auto r = L;
    for(int i = 1; i <= n; i++)
    {
        auto p = new DLnode;
        cin >> p->data;
        r->next = p;
        p->prior = r;
        p->next = nullptr;
        r = p;
    }
}
```

## 3.栈

```c++
#include <iostream>
#include <stack>
typedef struct{
    int coef;
    int exp;
}DataType;
stack<DataType> stk;



//压栈和弹栈(此处用int类型的栈举例，将1，2，3压栈，进行一次弹栈操作)
stack<int> stk;
stk.push(1);
stk.push(2);
stk.push(3);
stk.pop();
int a = stk.top();  //访问栈顶元素，a = 2
bool IsEmpty = stk.empty();  //判空操作
stk.clear();  //置空栈
stk.size();  //栈的大小
```

例1（进制转换,十进制转换为八进制）

```c++
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    int a;
    cin >> a;
    stack<int> b;
    while(a)
    {
        b.push(a % 8);
        a /= 8;
    }
    while(!b.empty())
    {
        cout << b.top();
        b.pop();
    }
    return 0;
}
```

例2（括号的检验）

```c++
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    string str;
    cin >> str;
    stack<char> mth;
    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{')
            mth.push(str[i]);
        else
        {
            if (mth.empty())
            {
                cout << "false";
                return 0;
            }
            else
            {
                if ((str[i] == ')' && mth.top() == '(') || (str[i] == ']' && mth.top() == '[') || (str[i] == '}' && mth.top() == '{'))
                {
                    mth.pop();
                }
                else
                {
                    cout << "false";
                    return 0;
                }
            }
        }
    }
    if (mth.empty())
    {
        cout << "true";
    }
    else
    {
        cout << "false";
    }
    return 0;
}
```

## 4.队列

#### (1)循环队列queue

```c++
#include <iostream>
#include <queue>
//此处也是以int类型为例子，进行入队和出队的演示(入队是队尾入，出队是队头出)
queue<int> q;
q.push(1);  //q: 1
q.push(2);  //q: 1 2 
q.push(3);  //q; 1 2 3
q.pop();    //q: 2 3
q.push(4);  //q: 2 3 4
q.push(5);  //q: 2 3 4 5
//取队头和取队尾
int a = q.front(); //a = 2
int b = q.back();  //b = 5
```

#### (2)优先队列priority_queue

```c++
#include <iostream>
#include <queue>

priority_queue<int> q;                              // 大根堆
priority_queue<int, vector<int>, greater<int>> q;   // 小根堆
priority_queue<pair<int, int>>q;
```

## 5.串、数组和广义表

#### (1)串(String)（串的模式匹配算法）（KMP）（背下来就好）

> 对于ne数组，比如模式串为aabaaf,那么ne数组为x010120(x表示0位置不填值)

```c++
#include <iostream>
using namespace std;
//p为模式串，长度为m，s为文本串，长度为n
const int M = 1e5 + 10, N = 1e6 + 10;
char p[M], s[N];
int ne[M];

int main()
{
	int m, n;
	cin >> m >> p + 1 >> n >> s + 1;
	for (int i = 2, j = 0; i <= m; i++)
	{
		while (j && p[i] != p[j + 1])
			j = ne[j];
		if (p[i] == p[j + 1])
			j++;
		ne[i] = j;
	}
	for (int i = 1, j = 0; i <= n; i++)
	{
		while (j && s[i] != p[j + 1])
			j = ne[j];
		if (s[i] == p[j + 1])
			j++;
		if (j == m)
		{
			cout << i - m << ' ';
			j = ne[j];
		}
	}
	return 0;
}
```

#### (2)数组

> 这个貌似没什么多的东西，就是一维数组，二维数组，三维数组，......

#### (3)特殊矩阵的压缩存储(如对称矩阵，对角矩阵，三角矩阵，稀疏矩阵)

> 稀疏矩阵：设在`m x n`的矩阵中有`t`个元素。令`delta = t / (m + n)`，当`delta<=0.05`时称为稀疏矩阵。
>
> 1. 可以利用三元组来解决：`(i,j,aij)`，存好后通常还需加上一个总体信息`(总行数，总列数，非零元素总个数)`，把它放在新结构数组的首元素上。
> 2. 利用十字链表，矩阵的每一个非零元素用一个结点表示，该结点除了`(行，列，值)`外，还有两个域，`right`和`down`，分别用于链接同一行的下一个元素和同一列的下一个元素。

#### (4)广义表 (与数组最大的区别是它可以存储不同类型的元素)

> 这个解释起来比较复杂，建议直接看视频：[第06周12--第4章串、数组和广义表12-4.5广义表_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nJ411V7bd/?p=74&spm_id_from=pageDriver&vd_source=0675cb12ad25471ef48565980a423f67)

	## 6.树和二叉树

## 6.树和二叉树

例1：数据压缩问题(将数据文件转换成由、1组成的二进制串，称之为编码)

(a)等长编码方案：比如`a编码为00，b编码为01，c编码为10，d编码为11`

(b)不等长编码方案1：比如`a编码为0，b编码为01，c编码为110，d编码为111`

(c)不等长编码方案2：比如`a编码为0，b编码为01，c编码为010，d编码为111`

例2：利用二叉树来求解表达式的值

**两中特殊形式的二叉树**

**1.满二叉树**

一颗深度为 k 且有 2^k^-1 个结点的二叉树称为满二叉树

**2.完全二叉树**

深度为 k 的具有 n 个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号 1~n 的结点一一对应时，称为完全二叉树。

#### 二叉树的顺序存储（按照满二叉树的结点编号，依次存放二叉树中的数据元素）这种适合于存储满二叉树和完全二叉树，其他类型较为浪费空间

#### 二叉树的链式存储（头指针指向根节点，每个结点的结构为`(l,data,r)`）

```c++
#include <iostream>
using namespace std;

typedef struct{
    int coef;
    int exp;
}DataType;
typedef	struct BiNode{
    DataType data;
    struct BiNode *l, *r;
}BiNode, *BiTree;
BiTree T = new BiNode;
```

#### 三叉链表的链式存储（与二叉链表相比，增添了一个指向上一个结点的指针域，`(l,data,parent,r)`）

```c++
#include <iostream>
using namespace std;

typedef struct{
    int coef;
    int exp;
}DataType;
typedef struct TiNode{
    DataType data;
    struct TiNode *l, *parent, *r;
}TiNode, *TiTree;
TiTree T = new TiNode;
```

#### 遍历二叉树

> 假设：
>
> - L：遍历左子树
> - D：访问根结点
> - R：遍历右子树 
>
> 则遍历整个二叉树的方案共有6种：
>
> DLR、LDR、LRD、DRL、RDL、RLD。
>
> **重点研究前三种，也就是先左后右**
>
> DLR：先序遍历
>
> LDR：中序遍历
>
> LRD：后序遍历
>
> 上面的先、中、后指的是根结点，也就是根左右、左根右、左右根。

==已知二叉树的先序序列和中序序列，或者后序序列和中序序列，可以唯一确定一颗二叉树。具体的做法可直接见视频：[第07周12--5.5 遍历二叉树和线索二叉树2--由遍历序列确定二叉树_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nJ411V7bd?p=87&spm_id_from=pageDriver&vd_source=0675cb12ad25471ef48565980a423f67)==

#### 二叉树的先序遍历、中序遍历、后序遍历(递归)

```c++
//先序遍历
void PreSearch(BiTree T)
{
    if(T == nullptr)
        return;
    cout << T->data;
    PreSearch(T->l);
    PreSearch(T->r);
}

//中序遍历
void InSearch(BiTree T)
{
    if(T == nullptr)
        return;
    InSearch(T->l);
    cout << T->data;
    InSearch(T->r);
}

//后序遍历
void PostSearch(BiTree T)
{
    if(T == nullptr)
        return;
    PostSearch(T->l);
    PostSearch(T->r);
    cout << T->data;
}
```

#### 二叉树的中序遍历(非递归)

```c++
//中序遍历
#include <stack>
void InSearch(BiTree T)
{
    BiTree p = T;
    stack<BiTree> stk;
    while(p || !stk.empty())
    {
        if(p)
        {
            stk.push(p);
            p = p->l;
        }
        else
        {
            p = stk.top();
            cout << p->data;
            stk.pop();
            p = p->r;
        }
    }
}
```

#### 二叉树的层次遍历

```c++
#include <queue>
void LevelSearch(BiTree)
{
    queue<BiTree> q;
    if(T)
        q.push(T);
    while(!q.empty())
    {
        BiTree temp = q.front();
        cout << temp->data;
        q.pop();
        if(temp->l)
            q.push(temp->l);
        if(temp->r)
            q.push(temp->r);
    }
}
```

#### 二叉树的建立

```c++
//假设二叉树的元素的值为char类型
typedef char DataType;
typedef struct BiNode{
    DataType data;
    struct BiNode *l, *r;
}BiNode, *BiTree;


BiTree T;  
//利用先序遍历实现二叉树的建立
void CreateBiTree(BiTree& T)
{
    DataType e;
    cin >> e;
    if (e == '#')  // 设置空结点的标志，可以自己设定条件
        T = nullptr;
    else  // 注意这里要写else
    {
        T = new BiNode;
        T->data = e;
        CreateBiTree(T->l);
        CreateBiTree(T->r);
    }
}
```

下面给出示例(先利用先序遍历创立一棵树，然后利用中序遍历输出)：

```c++
#include <iostream>
#include <stack>
using namespace std;

typedef char DataType;
typedef struct BiNode {
    DataType data;
    struct BiNode* l, * r;
}BiNode, * BiTree;


//利用先序遍历实现二叉树的建立
void CreateBiTree(BiTree& T)
{
    DataType e;
    cin >> e;
    if (e == '#')  // 设置空结点的标志，可以自己设定条件
        T = nullptr;
    else
    {
        T = new BiNode;
        T->data = e;
        CreateBiTree(T->l);
        CreateBiTree(T->r);
    }
}

void InSearch(BiTree T)
{
    BiTree p = T;
    stack<BiTree> stk;
    while (p || !stk.empty())
    {
        if (p)
        {
            stk.push(p);
            p = p->l;
        }
        else
        {
            p = stk.top();
            cout << p->data;
            stk.pop();
            p = p->r;
        }
    }
}

int main()
{
    BiTree T;
    CreateBiTree(T);
    cout << endl;
    InSearch(T);
    return 0;
}
```

```
输入样例：ABC##DE#G##F###
输出样例：CBEGDFA
```

#### 复制二叉树

```c++
void CopyBiTree(BiTree T, BiTree &Tnew)
{
    if(T == nullptr)
    {
        Tnew = nullptr;
        return;
    }
    else
    {
        Tnew = new BiNode;
        Tnew->data = T->data;
        CopyBiTree(T->l, Tnew->l);
        CopyBiTree(T->r, Tnew->r);
    }
}
```

#### 二叉树求深度和结点数

```c++
//二叉树求深度
int Depth(BiTree T)
{
    if(T == nullptr)
        return 0;
    else
        return Depth(T->l) > Depth(T->r) ? Depth(T->l) + 1 : Depth(T->r) + 1;
}

//二叉树求结点数
int Nodes(BiTree T)
{
    if(T == nullptr)
        return 0;
    else
        return 1 + Nodes(T->l) + Nodes(T->r);
}

//二叉树求叶子数
int Leaves(BiTree T)
{
    if(T == nullptr)
        return 0;
    if(T->l == nullptr && T->r == nullptr)
        return 1;
    else
        return Leaves(T->l) + Leaves(T->r);
}
```

#### 线索二叉树

> 如果某个结点的左指针为空，则将其指向其前驱；如果某个结点的右指针为空，则将其指向其后继。
>
> 不过这个不是很重要，就不写程序了。

#### 树和森林

> 森林是m(m>=0)棵互不相交的树的集合。
>
> 当树去掉根结点之后，变成森林；当给森林里面每棵树的根结点共同连向同一个新的根结点，变成树。

#### 树的存储

> 定义结构数组，存放树的结点，每个结点包含两个域（数据域和双亲域），`(data, parent)`。

双亲表示法：

```c++
struct PTNode{
    DataType data;
    int parent;  //存放其parent在数组中的索引
};
struct PTree{
    PTNode node[MAXSIZE];
    int root;  //存放根结点在数组中的索引
    int n;  //存放当前结点的个数
}
```

孩子链表：此处建议直接看视频：[第08周09--5.6树和森林2--树的存储结构2-孩子链表_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nJ411V7bd?p=96&spm_id_from=pageDriver&vd_source=0675cb12ad25471ef48565980a423f67)

> 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则 n 个结点有 n 个孩子链表（叶子的孩子链表为空表）。
> 而 n 个头指针又组成一个线性表，用顺序表存储。

```c++
//孩子结点的结构
struct CTNode{
    int child;  //孩子结点在数组中的索引
    CTNode *next;
};
//双亲结点的结构
struct CTBox{
    DataType data;
    int parent;  //可有可无，看具体需求，如果需要找双亲，那么加上就容易了
    CTNode *child;
}
//整体树的结构
struct CTree{
    CTBox Box[MAXSIZE];
    int root;
    int n;
}
```

孩子兄弟表示法(树转二叉树的基础)：

```c++
//节点的child指针域指向它的第一个孩子，sibling指向第一个兄弟
struct CSNode {
	DataType data;
	CSNode * child, *sibling;
};
```

#### 树与二叉树的相互转换

> 这里先空着，写不动了，以后有时间来补文字和图片



#### 哈夫曼树（最优二叉树）(带权路径长度最短的二叉树)

> 满二叉树不一定是哈夫曼树。
>
> 哈夫曼树中权越大的叶子离根越近。
>
> 具有相同带权结点的哈夫曼树不唯一。
>
> 哈夫曼树的结点的度为0或2，没有度为1的结点。
>
> 包含 n 个叶子结点的哈夫曼树中共有 2n-1 个结点。
>
> **贪心算法：构造哈夫曼树时首先选择权值小的叶子结点。**

```c++
#include <iostream>
using namespace std;

typedef struct{
    int weight;
    int parent, l, r;
}HNode, *HTree;

//初始化
void InitHTree(HTree &H, int n)
{
    //带有n个叶子结点的哈夫曼树共有2n-1个结点
    //通常哈夫曼树的顺序存储结构下标从1开始计数，因此使用数组时可将长度设为2n
    H = new HNode[2 * n];
    for(int i = 1; i <= 2 * n; i++)  //注意这里是2*n
        H[i].parent = H[i].l = H[i].r = 0;
    for(int i = 1; i <= n; i++)
        cin >> H[i].weight;
}

//选取最小的两个数(这个算法很细节)(划重点)
void SelectMin(HTree &H, int n, int &idx1, int &idx2)
{
    int min1, min2;
    min1 = min2 = INT_MAX;
    int pos1, pos2;
    pos1 = pos2 = 1;
    for(int i = 1; i <= n; i++)
    {
        if(H[i].parent == 0)  //parent==0说明该结点还未被结合
        {
            if(H[i].weight < min1)  //最初min1和min2是相同的，当找到比它们小的数的时候，把min1赋值给min2，把更小的数赋值给min1，这样保证了min1永远min2小
            {
                min2 = min1;
                pos2 = pos1;
                min1 = H[i].weight;
                pos1 = i;
            }
            else if(H[i].weight < min2)  //这里 else if 就相当于 min1 <= H[i].weight < min2 
            {
                min2 = H[i].weight;
                pos2 = i;
            }
        }
    }
    idx1 = pos1;
    idx2 = pos2;
}

//构造哈夫曼树
void CreateHTree(HTree &H, int n)
{
    if(n <= 1)
        return;
    InitHTree(H, n);
    int idx1, idx2;
    for(int i = n + 1; i < 2 * n; i++)
    {
        SelectMin(H, i - 1, idx1, idx2);
        H[idx1].parent = H[idx2].parent = i;
        H[i].weight = H[idx1].weight + H[idx2].weight;
        H[i].l = idx1;
        H[i].r = idx2;
    }
}
```

测试代码(函数如上面所定义，下面给出main函数)：

```c++
int main()
{
    int n;
    cin >> n;
    HTree H;
    CreateHTree(H, n);
    for(int i = 1; i < 2 * n; i++)
        cout << i << '\t' << "weight = " << H[i].weight << '\t' << "parent = " << H[i].parent << '\t' << "l = " << H[i].l << '\t' << "r = " << H[i].r << endl;
    return 0;
}
```

测试数据：

```
8
7 19 2 6 32 3 21 10
```

输出结果：

```
1       weight = 7      parent = 11     l = 0   r = 0
2       weight = 19     parent = 13     l = 0   r = 0
3       weight = 2      parent = 9      l = 0   r = 0
4       weight = 6      parent = 10     l = 0   r = 0
5       weight = 32     parent = 14     l = 0   r = 0
6       weight = 3      parent = 9      l = 0   r = 0
7       weight = 21     parent = 13     l = 0   r = 0
8       weight = 10     parent = 11     l = 0   r = 0
9       weight = 5      parent = 10     l = 3   r = 6
10      weight = 11     parent = 12     l = 9   r = 4
11      weight = 17     parent = 12     l = 1   r = 8
12      weight = 28     parent = 14     l = 10  r = 11
13      weight = 40     parent = 15     l = 2   r = 7
14      weight = 60     parent = 15     l = 12  r = 5
15      weight = 100    parent = 0      l = 13  r = 14
```

#### 哈夫曼编码

> 在远程通信中传递字符串时，需要转换成二进制的字符串。
> 即：让待传递字符串中出现次数多的字符采用尽可能短的编码，这样的话二进制字符串的编码就会缩短。
> 但，由于二进制只有0和1，所以有可能二进制编码转换成字符时，出现二义性，
> 所以要长度不等的编码，则必须使任一字符的编码都不是	另一个字符编码的前缀。

代码实现：（不需要新的函数，直接在main函数里面写，利用栈实现）

```c++
#include <stack>
int main()
{
    int n;
    cin >> n;
    HTree H;
    CreateHTree(H, n);
    stack<int> stk;
    int temp1, temp2;
    for (int i = 1; i <= n; i++)
    {
        temp1 = temp2 = i;
        while (1)
        {
            temp2 = temp1;  //保存temp1的原值
            temp1 = H[temp1].parent;  //temp1更新
            if (H[temp1].l == temp2)
                stk.push(0);
            else
                stk.push(1);
            if (H[temp1].parent == 0)
                break;
        }
        while (!stk.empty())
        {
            cout << stk.top();
            stk.pop();
        }
        cout << endl;
    }
    return 0;
}
```

测试数据：

```
7
40 30 15 5 4 3 3
```

输出结果：

```
0
10
110
11111
11110
11100
11101
```

#### 封装为函数：（两种写法，第一种为我的写法，第二种为老师的写法）

**第一种(我的写法)(利用栈和字符串容器)**

```c++
#include <stack>
#include <vector>
vector<string> CreateHuffmanCode(HTree T, int n)
{
    vector<string> HuffmanCode;
    stack<int> stk;
    int temp1, temp2;
    for (int i = 1; i <= n; i++)
    {
        temp1 = temp2 = i;
        while (H[temp1].parent)
        {
            temp2 = temp1;  //保存temp1的原值
            temp1 = H[temp1].parent;  //temp1更新
            if (H[temp1].l == temp2)
                stk.push(0);
            else
                stk.push(1);
        }
        string str = "";
        while (!stk.empty())
        {
            str += '0' + stk.top();
            stk.pop();
        }
        HuffmanCode.push_back(str);
    }
    return HuffmanCode;
}
```

测试代码：

```c++
int main()
{
    int n;
    cin >> n;
    HTree H;
    CreateHTree(H, n);
    vector<string> HuffmanCode = CreateHuffmanCode(H, n);
    for (int i = 0; i < HuffmanCode.size(); i++)
        cout << HuffmanCode[i] << endl;
    return 0;
}
```

测试数据：

```
7
40 30 15 5 4 3 3
```

测试结果：

```
0
10
110
11111
11110
11100
11101
```

**第二种(老师的写法)(利用字符数组和strcpy函数)**

```c++
typedef char** HuffmanCode;
HuffmanCode CreateHuffmanCode(HTree H,int n)
{
    HuffmanCode HC = new char*[n + 1];  //想要从1开始，因此分配n+1个空间
    char* hc = new char[n];
    hc[n - 1] = '\0';
    for(int i = 1; i <= n; i++)
    {
        int start = n - 1;
        int c = i;
        int f = H[i].parent;
        while(f)
        {
            start--;
            if(H[f].l == c)
            	hc[start] = '0';
            else
                hc[start] = '1';
            c = f;
            f = H[f].parent;
        }
        HC[i] = new char[n - start];
        strcpy(HC[i], &hc[start]);
    }
    delete hc;
    return HC;
}
```

测试代码：

```c++
int main()
{
    int n;
    cin >> n;
    HTree H;
    CreateHTree(H, n);
    HuffmanCode HC = CreateHuffmanCode(H, n);
    for (int i = 1; i <= n; i++)
        cout << HC[i] << endl;
    return 0;
}
```

测试数据：

```
7
40 30 15 5 4 3 3
```

测试结果：

```
0
10
110
11111
11110
11100
11101
```

==xdoj题目==

> 假设用于通信的电文由ｎ（4<n<30）个字符组成，字符在电文中出现的频度（权值）为w1w2…wn，试根据该权值序列构造哈夫曼树，并计算该树的带权路径长度。

> 问题输入 :一组数据，第１行为ｎ的值，第２行为ｎ个整数，表示字符的出现频度.

> 问题输出: 输出一个整数，表示所构造哈夫曼树的带权路径长度。 

> 样例：

> 8
> 7 19 2 6 32 3 21 10

> 输出样例：
> 261

**这题涉及二叉树带权路径长度的计算：事实上不需要死板地根据公式用所有叶结点的权值与其深度的乘积之和，只需要把所有非叶结点加起来就可得到。**

**而哈夫曼树的构造过程就是根据n个叶结点构造出n-1个非叶结点，这n-1个非叶结点刚好就在顺序存储的后n-1个位置里存着，因此只要构造哈夫曼树之后，对后n-1个元素求和即可**

**也就得到了最朴实无华的做法：**

```c++
#include <iostream>
using namespace std;

typedef struct{
    int weight;
    int parent, l, r;
}HNode, *HTree;

//初始化
void InitHTree(HTree &H, int n)
{
    //带有n个叶子结点的哈夫曼树共有2n-1个结点
    //通常哈夫曼树的顺序存储结构下标从1开始计数，因此使用数组时可将长度设为2n
    H = new HNode[2 * n];
    for(int i = 1; i <= 2 * n; i++)  //注意这里是2*n
        H[i].parent = H[i].l = H[i].r = 0;
    for(int i = 1; i <= n; i++)
        cin >> H[i].weight;
}

//选取最小的两个数(这个算法很细节)(划重点)
void SelectMin(HTree &H, int n, int &idx1, int &idx2)
{
    int min1, min2;
    min1 = min2 = INT_MAX;
    int pos1, pos2;
    pos1 = pos2 = 1;
    for(int i = 1; i <= n; i++)
    {
        if(H[i].parent == 0)  //parent==0说明该结点还未被结合
        {
            if(H[i].weight < min1)  //最初min1和min2是相同的，当找到比它们小的数的时候，把min1赋值给min2，把更小的数赋值给min1，这样保证了min1永远min2小
            {
                min2 = min1;
                pos2 = pos1;
                min1 = H[i].weight;
                pos1 = i;
            }
            else if(H[i].weight < min2)  //这里 else if 就相当于 min1 <= H[i].weight < min2 
            {
                min2 = H[i].weight;
                pos2 = i;
            }
        }
    }
    idx1 = pos1;
    idx2 = pos2;
}

//构造哈夫曼树
void CreateHTree(HTree &H, int n)
{
    if(n <= 1)
        return;
    InitHTree(H, n);
    int idx1, idx2;
    for(int i = n + 1; i < 2 * n; i++)
    {
        SelectMin(H, i - 1, idx1, idx2);
        H[idx1].parent = H[idx2].parent = i;
        H[i].weight = H[idx1].weight + H[idx2].weight;
        H[i].l = idx1;
        H[i].r = idx2;
    }
}

int main()
{
    int n;
    cin >> n;
    HTree H;
    CreateHTree(H, n);
    int sum = 0;
    for(int i = n + 1; i < 2 * n; i++)
        sum += H[i].weight;
    cout << sum;
    return 0;
}
```

**事实上不用这么做，只需根据哈夫曼树的构造过程用数组来做即可，也就是从权值里找到两个最小的，加起来作为新的值，而这些新的值其实就是哈夫曼顺序存储中后n-1个数。**

**从而有这样简单的写法：**

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 30;
int a[N];
int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++)
        cin >> a[i];
    sort(a, a + n);  //左闭右开
    int sum = 0;
    for(int i = 1; i < n; i++)
    {
        a[i] = a[i] + a[i - 1];
        sum += a[i];
        sort(a + i, a + n);
    }
    cout << sum;
    return 0;
}
```

## 7.图

- ### 邻接矩阵表示法

```c++
#define MAXVERTEX 100

//顶点类型一般是char类型
typedef struct{
    char vertex[MAXVERTEX];  //图的顶点向量
    int edge[MAXVERTEX][MAXVERTEX];  //图的邻接矩阵
    int vertices, edges;  //图的总顶点数和总边数,vertices是vertex的复数形式
}AMGraph;
```

**无向无权图**

```c++
//无向无权图(Undirected_Unweighted_AMGraph)(简写为UDUWAMGraph)
void CreateUDUWAMGraph(AMGraph &G)
{
    //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化
    memset(G.edge, 0, sizeof(G.edge));
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge(just like A B)" << endl;
        cin >> v1 >> v2;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = 1;
        G.edge[index2][index1] = 1;
    }
}
```

测试代码：

```c++
#include <iostream>
using namespace std;

#define MAXVERTEX 100

//顶点类型一般是char类型
typedef struct{
    char vertex[MAXVERTEX];  //图的顶点向量
    int edge[MAXVERTEX][MAXVERTEX];  //图的邻接矩阵
    int vertices, edges;  //图的总顶点数和总边数,vertices是vertex的复数形式
}AMGraph;

//无向无权图(Undirected_Unweighted)(简写为UDUW)
void CreateUDUWAMGraph(AMGraph &G)
{
    //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化
    memset(G.edge, 0, sizeof(G.edge));
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge(just like A B)" << endl;
        cin >> v1 >> v2;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = 1;
        G.edge[index2][index1] = 1;
    }
}

int main()
{
    AMGraph G;
    CreateUDUWAMGraph(G);
    for(int i = 0; i < G.vertices; i++)
    {
        for(int j = 0; j < G.vertices; j++)
            cout << G.edge[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

测试数据：

```
5 
6
A B C D E
A B
A D
B C
D C
C E
B E
```

输出结果：

```
0 1 0 1 0
1 0 1 0 1
0 1 0 1 1
1 0 1 0 0
0 1 1 0 0
```

**无向带权图**

```c++
//无向带权图(Undirected_weighted_AMGraph)(简写为UDWAMGraph)
void CreateUDWAMGraph(AMGraph &G)
{
    //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化(要注意初始化为MAXWEIGHT)
    memset(G.edge, 127, sizeof(G.edge));  //注意memset是按字节赋值，因此最大不能超过127(01111111),因此最终赋值之后不是int类型的最大值，而是01111111 01111111 01111111 01111111，即2139062143
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    int weight;
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge and weight(just like A B 2)" << endl;
        cin >> v1 >> v2 >> weight;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = weight;
        G.edge[index2][index1] = weight;
    }
}
```

测试代码：

```c++
#include <iostream>
using namespace std;

#define MAXVERTEX 100

//顶点类型一般是char类型
typedef struct{
    char vertex[MAXVERTEX];  //图的顶点向量
    int edge[MAXVERTEX][MAXVERTEX];  //图的邻接矩阵
    int vertices, edges;  //图的总顶点数和总边数,vertices是vertex的复数形式
}AMGraph;

//无向带权图(Undirected_weighted_AMGraph)(简写为UDWAMGraph)
void CreateUDWAMGraph(AMGraph &G)
{
    //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化(要注意初始化为MAXWEIGHT)
    memset(G.edge, 127, sizeof(G.edge));  //注意memset是按字节赋值，因此最大不能超过127(01111111),因此最终赋值之后不是int类型的最大值，而是01111111 01111111 01111111 01111111，即2139062143
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    int weight;
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge and weight(just like A B 2)" << endl;
        cin >> v1 >> v2 >> weight;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = weight;
        G.edge[index2][index1] = weight;
    }
}

int main()
{
    AMGraph G;
    CreateUDWAMGraph(G);
    for(int i = 0; i < G.vertices; i++)
    {
        for(int j = 0; j < G.vertices; j++)
            cout << G.edge[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

测试数据：

```
5 
6
A B C D E
A B 3
A D 4
B C 1
D C 2
C E 5
B E 6
```

输出结果：

```
2139062143 3 2139062143 4 2139062143
3 2139062143 1 2139062143 6
2139062143 1 2139062143 2 5
4 2139062143 2 2139062143 2139062143
2139062143 6 5 2139062143 2139062143
```

**有向无权图**

```c++
//有向无权图(Directed_Unweighted_AMGraph)(简写为DUWAMGraph)
void CreateDUWAMGraph(AMGraph &G)
{
    //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化(要注意初始化为MAXWEIGHT)
    memset(G.edge, 0, sizeof(G.edge));
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge(just like A B)" << endl;
        cin >> v1 >> v2;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = 1;
    }
}
```

测试代码：

```c++
#include <iostream>
using namespace std;

#define MAXVERTEX 100

//顶点类型一般是char类型
typedef struct{
    char vertex[MAXVERTEX];  //图的顶点向量
    int edge[MAXVERTEX][MAXVERTEX];  //图的邻接矩阵
    int vertices, edges;  //图的总顶点数和总边数,vertices是vertex的复数形式
}AMGraph;

//有向无权图(Directed_Unweighted_AMGraph)(简写为DUWAMGraph)
void CreateDUWAMGraph(AMGraph &G)
{
    //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化(要注意初始化为MAXWEIGHT)
    memset(G.edge, 0, sizeof(G.edge));
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge(just like A B)" << endl;
        cin >> v1 >> v2;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = 1;
    }
}

int main()
{
    AMGraph G;
    CreateDUWAMGraph(G);
    for(int i = 0; i < G.vertices; i++)
    {
        for(int j = 0; j < G.vertices; j++)
            cout << G.edge[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

测试数据：

```
5 
6
A B C D E
A B
A D
B C
D C
C E
B E
```

输出结果：

```
0 1 0 1 0
0 0 1 0 1
0 0 0 0 1
0 0 1 0 0
0 0 0 0 0
```

**有向带权图**

```c++
//有向带权图(Directed_Weighted_AMGraph)(简写为DWAMGraph)
void CreateDWAMGraph(AMGraph &G)
{
     //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化(要注意初始化为MAXWEIGHT)
    memset(G.edge, 127, sizeof(G.edge));  //注意memset是按字节赋值，因此最大不能超过127(01111111),因此最终赋值之后不是int类型的最大值，而是01111111 01111111 01111111 01111111，即2139062143
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    int weight;
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge and weight(just like A B 2)" << endl;
        cin >> v1 >> v2 >> weight;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = weight;
    }
}
```

测试代码：

```c++
#include <iostream>
using namespace std;

#define MAXVERTEX 100

//顶点类型一般是char类型
typedef struct{
    char vertex[MAXVERTEX];  //图的顶点向量
    int edge[MAXVERTEX][MAXVERTEX];  //图的邻接矩阵
    int vertices, edges;  //图的总顶点数和总边数,vertices是vertex的复数形式
}AMGraph;

//有向带权图(Directed_Weighted_AMGraph)(简写为DWAMGraph)
void CreateDWAMGraph(AMGraph &G)
{
     //初始化点的个数和边的条数
    cout << "Please input vertices:" << endl;
    cin >> G.vertices;
    cout << "Please input edges:" << endl;
    cin >> G.edges;
    //输入各顶点的名字,填充图的顶点向量
    cout << "Please input the name of vertex(just like A B C):" << endl;
    for(int i = 0; i < G.vertices; i++)
        cin >> G.vertex[i];
    //邻接矩阵初始化(要注意初始化为MAXWEIGHT)
    memset(G.edge, 127, sizeof(G.edge));  //注意memset是按字节赋值，因此最大不能超过127(01111111),因此最终赋值之后不是int类型的最大值，而是01111111 01111111 01111111 01111111，即2139062143
    //输入各条边，填充邻接矩阵
    char v1, v2;  //一条边的两个顶点
    int index1, index2;  //两个顶点的下标
    int weight;
    for(int i = 0; i < G.edges; i++)
    {
        cout << "(for " << (i + 1) << ")Please input the edge and weight(just like A B 2)" << endl;
        cin >> v1 >> v2 >> weight;
        for(int j = 0; j < G.vertices; j++)
        {
            if(v1 == G.vertex[j])
                index1 = j;
            if(v2 == G.vertex[j])
                index2 = j;
        }
        G.edge[index1][index2] = weight;
    }
}

int main()
{
    AMGraph G;
    CreateDWAMGraph(G);
    for(int i = 0; i < G.vertices; i++)
    {
        for(int j = 0; j < G.vertices; j++)
            cout << G.edge[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

测试数据：

```
5 
6
A B C D E
A B 3
A D 4
B C 1
D C 2
C E 5
B E 6
```

输出结果：

```
2139062143 3 2139062143 4 2139062143
2139062143 2139062143 1 2139062143 6
2139062143 2139062143 2139062143 2139062143 5
2139062143 2139062143 2 2139062143 2139062143
2139062143 2139062143 2139062143 2139062143 2139062143
```







