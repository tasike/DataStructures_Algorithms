# 数据结构与算法

# by tasike

速成可看如下笔记：

百度网盘的数据结构与算法(较详细，有关于算法的知识和笔记，用c实现)

本文用c++实现的，数据类型大多为包含两个int的结构体(因为统一写起来比较方便)

## 1.顺序表(Sequence List)

```c++
#include <iostream>
using namespace std;
const int MAXSIZE = 1024;

typedef struct{
    int coef;
    int exp;
}ElemType;
typedef struct{
    ElemType *elem;
    int length;
}SqList;

SqList L;
//顺序表初始化
int InitList(SqList &L) 
{
    L.elem = new ElemType[MAXSIZE];  //动态分配内存，若分配成功返回DataType类型的指针,否则返回空指针
    if(!L.elem)
    {
        cerr << "error" << endl;
        return 0;
    }
    L.length = 0;
    return 1;
}
//顺序表的销毁
void DestroyList(SqList &L)
{
    if(L.elem)
        delete L.elem;
}
//顺序表的清空
void ClearList(SqList &L)
{
    L.length = 0;
}
//判断顺序表是否为空
int IsEmpty(SqList &L)
{
    if(!L.length)
        return 1;
    else 
        return 0;
}
//顺序表的取值(获取i位置处的元素)(利用引用来取值)
int GetElem(SqList &L, int i, ElemType &e)
{
    if(i < 1 || i > L.length)
        return 0;
    e = L.elem[i - 1];
    return 1;
}
//顺序表的查找(按值查找)
int LocateList(SqList &L, ElemType e)
{
    for(int i = 0; i < L.length; i++)
    {
        if(L.elem[i] == e)
            return i + 1;
    }
    return 0; //返回0相当于没有这个元素
}
//顺序表的插入
int InsertList(SqList &L, int i, ElemType e)
{
    if(i < 1 || i > L.length)
        return 0;
    if(L.length == MAXSIZE)
        return 0;
    for(int j = L.length - 1; j >= i - 1; j--)
        L.elem[j + 1] = L.elem[j];
    L.elem[i - 1] = e;
    L.length++;  //记得要增加表长
    return 1;
}
//顺序表的删除
int DeleteList(SqList &L, int i)
{
    if(i < 1 || i > L.length)
        return 0;
    for(int j = i - 1; j < L.length; j++)
        L.elem[j] = L.elem[j + 1];
    L.length--;  //记得要减小表长
	return 1;
}
```

## 2.链表(LinkList)

> - 单链表：只有一个指针域的链表
> - 双向链表：有两个指针域分别指向前驱和后继的链表
> - 循环链表：首尾相接的链表

#### (1)单链表

```c++
#include <iostream>
using namespace std;

typedef struct{
    int coef;
    int exp;
}DataType;
typedef struct Lnode{
	DataType data;
    struct Lnode *next;
}Lnode, *LinkList;

LinkList L;
//链表的初始化
int InitList(LinkList &L)
{
    L = new Lnode;
    L->next = nullptr;
    return 1;
}
//尾插法
void CreateList(LinkList &L, int n)
{
    auto r = L;
    for(int i = 1; i <= n; i++)
    {
        auto p = new Lnode;
        cin >> p->data;
        p->next = nullptr;
        r->next = p;
        r = p;
    }
}
//判断链表是否为空
int IsEmpty(LinkList &L)
{
    if(!L->next)
        return 1;
    else 
        return 0;
}
//链表的销毁
void DeleteList(LinkList &L)
{
    while(L)
    {
        auto p = L->next;
        delete L;
        L = p;
    }
}
//链表的清空
void ClearList(LinkList &L)
{
    auto p = L->next;
    while(p)
    {
        auto q = p->next;
        delete p;
        p = q;
    }
    L->next = nullptr;  //注意这里记得最后要把L->next置为空
}
//求链表的表长
int GetLength(LinkList &L)
{
    auto p = L->next;
    int length = 0;
    while(p)
    {
        length++;
        p = p->next;
    }
    return length;
}
//去链表第i个元素
int GetElem(LinkList &L, int i, DataType &e)
{
    if(i < 1)
        return 0;
    auto p = L;
    for(int j = 1; j <= i; j++)
    {
        p = p->next;
        if(!p)
            return 0;
    }
    e = p->data;
    return 1;
}
//链表按值查找
int LocateElem(LinkList &L, DataType &e)
{
    auto p = L;
    int i = 0;
    while(p && p->data != e)
    {
        p = p->next;
        i++;
    }
    if(p)
        return i;
    else 
        return 0;  //0就是没找到，因为位置是从1开始的
}
//在第i个结点前插入元素(要先找到第i-1个结点)
int InsertList(LinkList &L, int i, DataType e)
{
    auto p = L;
    int j = 0;
    while(p && j <= i - 1)
    {
        p = p->next;
        j++;
    }
    if(p)
    {
        auto q = new Lnode;
    	q->data = e;
    	q->next = p->next;
    	p->next = q;
    	return 1;
    }
    else
        return 0;
}
//删除第i个结点
int DeleteList(LinkList &L, int i)
{
    auto p = L;
    int j = 0;
    while(p && j <= i - 1)
    {
        p = p->next;
        j++;
    }
    if(!(p->next))
        return 0;
    auto q = p->next;
    p->next = q->next;
    delete q;  //记得要释放空间
    return 1;
}
```

#### (2)循环链表(一般都是用尾指针表示)

```c++
#include <iostream>
using namespace std;

typedef struct CLnode
{
    ElemType data;
    CLnode *next;
}CLnode, *CircList;

CircList L;
//循环链表的初始化
void InitList(CircList &L)
{
    L = new	CircList;
    L->next = L;
}


while(p) -------> while(p != L)
```

#### (3)双向链表

```c++
#include <iostream>
using namespace std;

typedef struct DLnode{
    DataType data;
    struct DLnode *prior, *next;
}DLnode, *DLinkList;

DLinkList L;
//双向链表的初始化
void InitList(DLinkList &L)
{
    L = new DLnode;
    L->prior = nullptr;
    L->next = nullptr;
}
//尾插法建立双向链表
void CreateList(DLinkList &L, int n)
{
    auto r = L;
    for(int i = 1; i <= n; i++)
    {
        auto p = new DLnode;
        cin >> p->data;
        r->next = p;
        p->prior = r;
        p->next = nullptr;
        r = p;
    }
}
```

## 3.栈

```c++
#include <iostream>
#include <stack>
typedef struct{
    int coef;
    int exp;
}DataType;
stack<DataType> stk;



//压栈和弹栈(此处用int类型的栈举例，将1，2，3压栈，进行一次弹栈操作)
stack<int> stk;
stk.push(1);
stk.push(2);
stk.push(3);
stk.pop();
int a = stk.top();  //访问栈顶元素，a = 2
bool IsEmpty = stk.empty();  //判空操作
stk.clear();  //置空栈
stk.size();  //栈的大小
```

例1（进制转换,十进制转换为八进制）

```c++
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    int a;
    cin >> a;
    stack<int> b;
    while(a)
    {
        b.push(a % 8);
        a /= 8;
    }
    while(!b.empty())
    {
        cout << b.top();
        b.pop();
    }
    return 0;
}
```

例2（括号的检验）

```c++
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    string str;
    cin >> str;
    stack<char> mth;
    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{')
            mth.push(str[i]);
        else
        {
            if (mth.empty())
            {
                cout << "false";
                return 0;
            }
            else
            {
                if ((str[i] == ')' && mth.top() == '(') || (str[i] == ']' && mth.top() == '[') || (str[i] == '}' && mth.top() == '{'))
                {
                    mth.pop();
                }
                else
                {
                    cout << "false";
                    return 0;
                }
            }
        }
    }
    if (mth.empty())
    {
        cout << "true";
    }
    else
    {
        cout << "false";
    }
    return 0;
}
```

例3（表达式求值）

```c++
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    
    return 0;
}
```



## 4.队列

#### (1)循环队列queue

```c++
#include <iostream>
#include <queue>
//此处也是以int类型为例子，进行入队和出队的演示(入队是队尾入，出队是队头出)
queue<int> q;
q.push(1);  //q: 1
q.push(2);  //q: 1 2 
q.push(3);  //q; 1 2 3
q.pop();    //q: 2 3
q.push(4);  //q: 2 3 4
q.push(5);  //q: 2 3 4 5
//取队头和取队尾
int a = q.front(); //a = 2
int b = q.back();  //b = 5
```

#### (2)优先队列priority_queue

```c++
#include <iostream>
#include <queue>

priority_queue<int> q;                              // 大根堆
priority_queue<int, vector<int>, greater<int>> q;   // 小根堆
priority_queue<pair<int, int>>q;
```

## 5.串、数组和广义表

#### (1)串(String)（串的模式匹配算法）（KMP）（背下来就好）

> 对于ne数组，比如模式串为aabaaf,那么ne数组为x010120

```c++
#include <iostream>
using namespace std;
//p为模式串，长度为m，s为文本串，长度为n
const int M = 1e5 + 10, N = 1e6 + 10;
char p[M], s[N];
int ne[M];

int main()
{
	int m, n;
	cin >> m >> p + 1 >> n >> s + 1;
	for (int i = 2, j = 0; i <= m; i++)
	{
		while (j && p[i] != p[j + 1])
			j = ne[j];
		if (p[i] == p[j + 1])
			j++;
		ne[i] = j;
	}
	for (int i = 1, j = 0; i <= n; i++)
	{
		while (j && s[i] != p[j + 1])
			j = ne[j];
		if (s[i] == p[j + 1])
			j++;
		if (j == m)
		{
			cout << i - m << ' ';
			j = ne[j];
		}
	}
	return 0;
}
```

#### (2)数组

> 这个貌似没什么多的东西，就是一维数组，二维数组，三维数组，......

#### (3)特殊矩阵的压缩存储(如对称矩阵，对角矩阵，三角矩阵，稀疏矩阵)

> 稀疏矩阵：设在`m x n`的矩阵中有`t`个元素。令`delta = t / (m + n)`，当`delta<=0.05`时称为稀疏矩阵。
>
> 1. 可以利用三元组来解决：`(i,j,aij)`，存好后通常还需加上一个总体信息`(总行数，总列数，非零元素总个数)`，把它放在新结构数组的首元素上。
> 2. 利用十字链表，矩阵的每一个非零元素用一个结点表示，该结点除了`(行，列，值)`外，还有两个域，`right`和`down`，分别用于链接同一行的下一个元素和同一列的下一个元素。

#### (4)广义表 (与数组最大的区别是它可以存储不同类型的元素)

> 这个解释起来比较复杂，建议直接看视频：[第06周12--第4章串、数组和广义表12-4.5广义表_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nJ411V7bd/?p=74&spm_id_from=pageDriver&vd_source=0675cb12ad25471ef48565980a423f67)

	## 6.树和二叉树

## 6.树和二叉树

例1：数据压缩问题(将数据文件转换成由、1组成的二进制串，称之为编码)

(a)等长编码方案：比如`a编码为00，b编码为01，c编码为10，d编码为11`

(b)不等长编码方案1：比如`a编码为0，b编码为01，c编码为110，d编码为111`

(c)不等长编码方案2：比如`a编码为0，b编码为01，c编码为010，d编码为111`

例2：利用二叉树来求解表达式的值

**两中特殊形式的二叉树**

**1.满二叉树**

一颗深度为 k 且有 2^k^-1 个结点的二叉树称为满二叉树

**2.完全二叉树**

深度为 k 的具有 n 个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号 1~n 的结点一一对应时，称为完全二叉树。

#### 二叉树的顺序存储（按照满二叉树的结点编号，依次存放二叉树中的数据元素）这种适合于存储满二叉树和完全二叉树，其他类型较为浪费空间

#### 二叉树的链式存储（头指针指向根节点，每个结点的结构为`(l,data,r)`）

```c++
#include <iostream>
using namespace std;

typedef struct{
    int coef;
    int exp;
}DataType;
typedef	struct BiNode{
    DataType data;
    struct BiNode *l, *r;
}BiNode, *BiTree;
BiTree T = new BiNode;
```

#### 三叉链表的链式存储（与二叉链表相比，增添了一个指向上一个结点的指针域，`(l,data,parent,r)`）

```c++
#include <iostream>
using namespace std;

typedef struct{
    int coef;
    int exp;
}DataType;
typedef struct TiNode{
    DataType data;
    struct TiNode *l, *parent, *r;
}TiNode, *TiTree;
TiTree T = new TiNode;
```

#### 遍历二叉树

> 假设：
>
> - L：遍历左子树
> - D：访问根结点
> - R：遍历右子树 
>
> 则遍历整个二叉树的方案共有6种：
>
> DLR、LDR、LRD、DRL、RDL、RLD。
>
> **重点研究前三种，也就是先左后右**
>
> DLR：先序遍历
>
> LDR：中序遍历
>
> LRD：后序遍历
>
> 上面的先、中、后指的是根结点，也就是根左右、左根右、左右根。

==已知二叉树的先序序列和中序序列，或者后序序列和中序序列，可以唯一确定一颗二叉树。具体的做法可直接见视频：[第07周12--5.5 遍历二叉树和线索二叉树2--由遍历序列确定二叉树_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nJ411V7bd?p=87&spm_id_from=pageDriver&vd_source=0675cb12ad25471ef48565980a423f67)==

#### 二叉树的先序遍历、中序遍历、后序遍历(递归)

```c++
//先序遍历
void PreSearch(BiTree T)
{
    if(T == nullptr)
        return;
    cout << T->data;
    PreSearch(T->l);
    PreSearch(T->r);
}

//中序遍历
void InSearch(BiTree T)
{
    if(T == nullptr)
        return;
    InSearch(T->l);
    cout << T->data;
    InSearch(T->r);
}

//后序遍历
void PostSearch(BiTree T)
{
    if(T == nullptr)
        return;
    PostSearch(T->l);
    PostSearch(T->r);
    cout << T->data;
}
```

#### 二叉树的中序遍历(非递归)

```c++
//中序遍历
#include <stack>
void InSearch(BiTree T)
{
    BiTree p = T;
    stack<BiTree> stk;
    while(p || !stk.empty())
    {
        if(p)
        {
            stk.push(p);
            p = p->l;
        }
        else
        {
            p = stk.top();
            cout << p->data;
            stk.pop();
            p = p->r;
        }
    }
}
```

#### 二叉树的层次遍历

```c++
#include <queue>
void LevelSearch(BiTree)
{
    queue<BiTree> q;
    if(T)
        q.push(T);
    while(!q.empty())
    {
        BiTree temp = q.front();
        cout << temp->data;
        q.pop();
        if(temp->l)
            q.push(temp->l);
        if(temp->r)
            q.push(temp->r);
    }
}
```

#### 二叉树的建立

```c++
//假设二叉树的元素的值为char类型
typedef char DataType;
typedef struct BiNode{
    DataType data;
    struct BiNode *l, *r;
}BiNode, *BiTree;


BiTree T;  
//利用先序遍历实现二叉树的建立
void CreateBiTree(BiTree& T)
{
    DataType e;
    cin >> e;
    if (e == '#')  // 设置空结点的标志，可以自己设定条件
        T = nullptr;
    else  // 注意这里要写else
    {
        T = new BiNode;
        T->data = e;
        CreateBiTree(T->l);
        CreateBiTree(T->r);
    }
}
```

下面给出示例(先利用先序遍历创立一棵树，然后利用中序遍历输出)：

```c++
#include <iostream>
#include <stack>
using namespace std;

typedef char DataType;
typedef struct BiNode {
    DataType data;
    struct BiNode* l, * r;
}BiNode, * BiTree;


//利用先序遍历实现二叉树的建立
void CreateBiTree(BiTree& T)
{
    DataType e;
    cin >> e;
    if (e == '#')  // 设置空结点的标志，可以自己设定条件
        T = nullptr;
    else
    {
        T = new BiNode;
        T->data = e;
        CreateBiTree(T->l);
        CreateBiTree(T->r);
    }
}

void InSearch(BiTree T)
{
    BiTree p = T;
    stack<BiTree> stk;
    while (p || !stk.empty())
    {
        if (p)
        {
            stk.push(p);
            p = p->l;
        }
        else
        {
            p = stk.top();
            cout << p->data;
            stk.pop();
            p = p->r;
        }
    }
}

int main()
{
    BiTree T;
    CreateBiTree(T);
    cout << endl;
    InSearch(T);
    return 0;
}
```

```
输入样例：ABC##DE#G##F###
输出样例：CBEGDFA
```

#### 复制二叉树

```c++
void CopyBiTree(BiTree T, BiTree &Tnew)
{
    if(T == nullptr)
    {
        Tnew = nullptr;
        return;
    }
    else
    {
        Tnew = new BiNode;
        Tnew->data = T->data;
        CopyBiTree(T->l, Tnew->l);
        CopyBiTree(T->r, Tnew->r);
    }
}
```

#### 二叉树求深度和结点数

```c++
//二叉树求深度
int Depth(BiTree T)
{
    if(T == nullptr)
        return 0;
    else
        return Depth(T->l) > Depth(T->r) ? Depth(T->l) + 1 : Depth(T->r) + 1;
}

//二叉树求结点数
int Nodes(BiTree T)
{
    if(T == nullptr)
        return 0;
    else
        return 1 + Nodes(T->l) + Nodes(T->r);
}

//二叉树求叶子数
int Leaves(BiTree T)
{
    if(T == nullptr)
        return 0;
    if(T->l == nullptr && T->r == nullptr)
        return 1;
    else
        return Leaves(T->l) + Leaves(T->r);
}
```

#### 线索二叉树

> 如果某个结点的左指针为空，则将其指向其前驱；如果某个结点的右指针为空，则将其指向其后继。
>
> 不过这个不是很重要，就不写程序了。

#### 树和森林

> 森林是m(m>=0)棵互不相交的树的集合。
>
> 当树去掉根结点之后，变成森林；当给森林里面每棵树的根结点共同连向同一个新的根结点，变成树。

#### 树的存储

> 定义结构数组，存放树的结点，每个结点包含两个域（数据域和双亲域），`(data, parent)`。

双亲表示法：

```c++
struct PTNode{
    DataType data;
    int parent;  //存放其parent在数组中的索引
};
struct PTree{
    PTNode node[MAXSIZE];
    int root;  //存放根结点在数组中的索引
    int n;  //存放当前结点的个数
}
```

孩子链表：此处建议直接看视频：[第08周09--5.6树和森林2--树的存储结构2-孩子链表_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nJ411V7bd?p=96&spm_id_from=pageDriver&vd_source=0675cb12ad25471ef48565980a423f67)

> 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则 n 个结点有 n 个孩子链表（叶子的孩子链表为空表）。
> 而 n 个头指针又组成一个线性表，用顺序表存储。

```c++
//孩子结点的结构
struct CTNode{
    int child;  //孩子结点在数组中的索引
    CTNode *next;
};
//双亲结点的结构
struct CTBox{
    DataType data;
    int parent;  //可有可无，看具体需求，如果需要找双亲，那么加上就容易了
    CTNode *child;
}
//整体树的结构
struct CTree{
    CTBox Box[MAXSIZE];
    int root;
    int n;
}
```

孩子兄弟表示法(树转二叉树的基础)：

```c++
//节点的child指针域指向它的第一个孩子，sibling指向第一个兄弟
struct CSNode {
	DataType data;
	CSNode * child, *sibling;
};
```

#### 树与二叉树的相互转换

> 这里先空着，写不动了，以后有时间来补文字和图片



#### 哈夫曼树（最优二叉树）













